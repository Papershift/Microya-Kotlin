package com.papershift.microya.core

import kotlinx.serialization.PolymorphicSerializer
import kotlinx.serialization.Serializer
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.modules.SerializersModule
import okhttp3.HttpUrl.Companion.toHttpUrl
import okhttp3.MultipartBody
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.lang.IllegalArgumentException
import java.net.URL

/**  Defines the structure of a JSON based API endpoint collection. */
abstract class Endpoint {
    /** The relevant HTTP request methods defined in the HTTP standard. */
    sealed class HttpMethod {
        object Get : HttpMethod()
        object Head : HttpMethod()
        data class Post<T>(val body: T) : HttpMethod()
        data class Put<T>(val body: T) : HttpMethod()
        data class Patch<T>(val body: T) : HttpMethod()
        object Delete : HttpMethod()
    }

    /** The subpath to add onto the `baseURL` for a specific endpoint. */
    abstract val subpath: String

    /** The HTTP method to use for a specific endpoint.Contains also the body for POST, PUT & PATCH.
     */
    abstract val method: HttpMethod

    /** The headers to send with every request or per specific endpoint. */
    abstract val headers: Map<String, String>

    /** The query parameters to send for a specific endpoint
     * (part after ? in URLs, e.g. google.com?query=Harry+Potter).
     */
    abstract val queryParameters: Map<String, String>

    /**
     *  The mocked response for testing purposes. Will be returned instead of making actual calls
     *  when [ApiProvider] [mockingBehavior] is set.
     */
    abstract val mockedResponse: MockedResponse?
    /**
     * Builds the request to be sent to the server
     * @param baseUrl is the base url of the request.
     * @param requestJsonFormatter is the [Json] formatter used to encode models to JSON.
     * @return is the formed request containing the base url, header and body to be sent to the
     * server.
     */
    fun buildRequest(baseUrl: String, requestJsonFormatter: Json): Request {
        val requestBuilder = addHeaders(baseUrl)

        when (method) {
            HttpMethod.Get -> requestBuilder.get()
            HttpMethod.Head -> requestBuilder.head()
            is HttpMethod.Post<*> -> {
                val data: Any = (method as HttpMethod.Post<*>).body as Any
                val jsonString = formatJson(requestJsonFormatter, data)
                requestBuilder.post(jsonString.toRequestBody())
            }
            is HttpMethod.Put<*> -> {
                val data: Any = (method as HttpMethod.Put<*>).body as Any
                val jsonString = formatJson(requestJsonFormatter, data)
                requestBuilder.put(jsonString.toRequestBody())
            }
            is HttpMethod.Patch<*> -> {
                val data: Any = (method as HttpMethod.Patch<*>).body as Any
                val jsonString = formatJson(requestJsonFormatter, data)
                requestBuilder.patch(jsonString.toRequestBody())
            }
            HttpMethod.Delete -> requestBuilder.delete()
        }

        return requestBuilder.build()
    }

    private fun addHeaders(baseUrl: String): Request.Builder {
        val buildRequestUrl = buildRequestUrl(baseUrl)
        val requestBuilder = Request.Builder().url(buildRequestUrl)
        for ((name, value) in headers) {
            requestBuilder.addHeader(name, value)
        }
        return requestBuilder
    }

    /**
     * After declaring the serializer module.
     * We must explicitly pass an instance of PolymorphicSerializer for
     * the base class Any as the first parameter to the encodeToJsonElement function.
     * We're filtering out serializer_type json key(our custom class classDiscriminator
     * declared in the [Serializer]) here because we don't need it.
     * And also because it affects the backend.
     * This serializer key is generated by kotlinx serialisation library automatically when using a
     * polymorphic [SerializersModule]
     * and as at when this function was created it could not be disabled.
     *
     * @param data about to be sent to the server
     * @return formatted json string
     */
    private fun formatJson(requestJsonFormatter: Json, data: Any): String {
        val filteredJson = encodeData(requestJsonFormatter, data)
        return requestJsonFormatter.encodeToString(filteredJson)
    }

    private fun encodeData(
        requestJsonFormatter: Json,
        data: Any
    ): Map<String, JsonElement> {
        val jsonString =
            requestJsonFormatter.encodeToJsonElement(PolymorphicSerializer(Any::class), data)
        return jsonString.jsonObject.filterNot { it.key == "type" }
    }

    private fun buildRequestUrl(baseUrl: String): URL {
        val uriBuilder = baseUrl.toHttpUrl().newBuilder()

        uriBuilder.addEncodedPathSegments((subpath))
        for ((key, value) in queryParameters) {
            uriBuilder.addEncodedQueryParameter(key, value)
        }
        return uriBuilder.build().toUrl()
    }

    /**
     *  Creates a [MockedResponse] object with the given status, body JSON string (optional) and
     *  headers (optional).
     */
    fun mockJsonString(
        statusCode: Int,
        bodyJson: String,
        headers: Map<String, String> = emptyMap()
    ): MockedResponse =
        MockedResponse(subpath, statusCode, bodyJson, headers)

    /**
     * Creates a [MockedResponse] object with the given status, body [Serializable] object and
     * headers (optional).
     */
    inline fun <reified T> mockResponseObject(
        statusCode: Int,
        bodySerializable: T,
        headers: Map<String, String> = emptyMap()
    ): MockedResponse =
        MockedResponse(subpath, statusCode, Json.encodeToString(bodySerializable), headers)

    /**
     * Builds a multipart request to be sent to the server
     * @param baseUrl is the base url of the request.
     * @param requestJsonFormatter is the [Json] formatter used to encode models to JSON.
     * @param fileDataParts is the files to included in a multipart request.
     * @return is the formed request containing the base url, header and body to be sent to the
     * server.
     */
    fun buildMultipartRequest(baseUrl: String, requestJsonFormatter: Json, fileDataParts: List<FileDataPart>): Request {
        val requestBuilder = addHeaders(baseUrl)
        val multiPartBuilder = MultipartBody.Builder().setType(MultipartBody.FORM)
        fileDataParts.forEach { fileDataPart: FileDataPart ->
            multiPartBuilder.addFormDataPart(
                fileDataPart.name,
                fileDataPart.file.nameWithoutExtension,
                fileDataPart.asRequestBody()
            )
        }
        when (val httpMethod = method) {
            is HttpMethod.Patch<*> -> {
                val multipartBody =
                    buildMultiPartFromJson(requestJsonFormatter, httpMethod.body!!, multiPartBuilder)
                requestBuilder.patch(multipartBody)
            }
            is HttpMethod.Post<*> -> {
                val multipartBody =
                    buildMultiPartFromJson(requestJsonFormatter, httpMethod.body!!, multiPartBuilder)
                requestBuilder.post(multipartBody)
            }
            is HttpMethod.Put<*> -> {
                val multipartBody =
                    buildMultiPartFromJson(requestJsonFormatter, httpMethod.body!!, multiPartBuilder)
                requestBuilder.put(multipartBody)
            }
            else -> {
                throw IllegalArgumentException("$method is not allowed for a multipart request.")
            }
        }
        return requestBuilder.build()
    }

    private fun buildMultiPartFromJson(
        requestJsonFormatter: Json,
        body: Any,
        multiPartBuilder: MultipartBody.Builder
    ): MultipartBody {
        val encodedJson = encodeData(requestJsonFormatter, body)
        encodedJson.forEach {
            multiPartBuilder.addFormDataPart(it.key, it.value.toString())
        }
        return multiPartBuilder.build()
    }
}